<!DOCTYPE html>
<!--
    author: Bryan Haberberger <bryan.j.haberberger@slu.edu>

    This is a small set of recipes for handling Lists or Sets of information whereby an Annotation is a List or Set annotation containing the values in an array.  These are simple recipes for how to record these kinds of annotations using DEER.  
    Ex. http://devstore.rerum.io/v1/id/5e542de5e4b0a6b3a238f1a2
-->
<html>

<head>
    <title>Recipe: Capture List Data</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://unpkg.com/chota@latest">
    <style>
        h4{
            margin-bottom: 0px;
        }
    </style>
</head>

<body>
    <form id="newStuffForm" deer-type="Thing" deer-context="http://schema.org">
        <input type="hidden" deer-key="creator" value="DEER_RECIPE_LIST_ANNOTATION_GENERATOR">

        <h4>Multi Select:</h4>
        <label>
            Here the user can choose values by selecting the value they wish to include from the multi select area.  The values will be stored in a Set or List Annotation as an array, depending on which you choose. The values are pre-determined for the user.  The delimeter is provided here in the HTML and can be customized.    
        </label>
        <input type="hidden" deer-key="DEER:multiSelect" deer-input-type="Set" deer-array-delimeter=":" >
        <select multiple oninput="handleMultiSelect(event)">
            <option value="Accommodation" >Accommodation</option>
            <option value="Landform" >Landform</option>
            <option value="Residence" >Residence</option>
            <option value="Hall" >Hall</option>
            <option value="Venue" >Venue</option>
        </select>
        <pre class="choices" id="multiChoices"></pre>

        <h4>Checkbox Group:</h4>
        <label>
            Here the user can choose values by selecting the checkbox by the value they wish to include.  The values will be stored in a Set or List Annotation as an array. Here the values are pre-determined.  No delimeter was provided so the comma (,) is used by default.
        </label>
        <input type="hidden" deer-key="DEER:checkboxGroup" deer-input-type="List" >
        <div>
            <label><input type="checkbox" name="sports[]" value="cycling" onclick="handleCheckboxGroup(event)" /> cycling</label>
            <label><input type="checkbox" name="sports[]" value="running" onclick="handleCheckboxGroup(event)" /> running</label>
            <label><input type="checkbox" name="sports[]" value="walking" onclick="handleCheckboxGroup(event)" /> walking</label>
            <label><input type="checkbox" name="sports[]" value="swimming" onclick="handleCheckboxGroup(event)" /> swimming</label>
            <label><input type="checkbox" name="sports[]" value="team sports" onclick="handleCheckboxGroup(event)" /> team sport(s)</label>
            <label><input type="checkbox" name="sports[]" value="fishing" onclick="handleCheckboxGroup(event)" /> fishing</label>
        </div>
        <pre class="choices" id="checkboxChoices"></pre>

        <h4>Textual Input Group:</h4>
        <label>
            Here the user can type whatever they want into the text area. Each entry will be stored as an item in an array of a Set or List Annotation. Note that a user could provide the delimeter used in the background and cause unexpected array items in certain scenarios.  Be mindful of what delimeter you use and/or how you handle user input that contains the delimeter.  In this example, the delimeiter is colon (:) and there is no mindful handling of user input.
        </label>
        <input type="hidden" deer-key="DEER:textGroup" deer-input-type="Set" deer-array-delimeter=":" >
        <div>
            <label>User Input 1</label><input type="text" onchange="handleTextGroup(event)" />
            <label>User Input 2</label><input type="text" onchange="handleTextGroup(event)" />
            <label>User Input 3</label><input type="text" onchange="handleTextGroup(event)" />
            <label>User Input 4</label><input type="text" onchange="handleTextGroup(event)" />
            <label>User Input 5</label><input type="text" onchange="handleTextGroup(event)" />
        </div>
        <pre class="choices" id="textChoices"></pre>

        <input class="button primary" type="submit">
    </form>
    <script>

        /**
            * A recipe for handling values generated by users through a multi-select interface.  Since an HTML input tracks this value
            * it must be converted into a string to be placed on an attribute in the DOM.  DEER will handle forming the List Annotation object so long
            * as the string value on the input element can be split() on your values (note your delimeter).  
        */
        function handleMultiSelect(event){
            let sel = event.target
            let arr = Array.from(sel.selectedOptions).map(option=>option.value)
            let delim = (sel.previousElementSibling.hasAttribute("deer-array-delimeter")) ? sel.previousElementSibling.getAttribute("deer-array-delimeter") : ","
            let str_arr = arr.join(delim)
            //Your hidden input that tracks array values should always be just before the element containing the multitude of options
            sel.previousElementSibling.value=str_arr
            sel.previousElementSibling.setAttribute("value", str_arr)
            multiChoices.innerHTML = str_arr
        }

        /**
            * A recipe for handling annotations generated by users through multiple checkbox selections.  Since an HTML input tracks this value
            * it must be converted into a string to be placed on an attribute in the DOM.  DEER will handle forming the List Annotation object so long
            * as the string value on the input element can be split() on your values (note your delimeter).  
        */
        function handleCheckboxGroup(event){
            let container = event.target.parentElement.parentElement //because of the <label>
            let checks = Array.from(container.getElementsByTagName("INPUT"))
            let value_arr =  Array.from(checks.filter(check => check.checked).map(input=>input.value))
            let delim = (container.previousElementSibling.hasAttribute("deer-array-delimeter")) ? container.previousElementSibling.getAttribute("deer-array-delimeter") : ","
            let str_arr = value_arr.join(delim)
            //Your hidden input that tracks array values should always be just before the element containing the multitude of options
            container.previousElementSibling.value=str_arr
            container.previousElementSibling.setAttribute("value", str_arr)
            checkboxChoices.innerHTML = str_arr
        }

        /**
            * A recipe for handling values generated by users through multiple textual input options.  Since an HTML input tracks this value
            * it must be converted into a string to be placed on an attribute in the DOM.  DEER will handle forming the List Annotation object so long
            * as the string value on the input element can be split() on your values (note your delimeter).  
            * 
            * Be aware that the user provided input may contain the value you are using for a delimeter.
            * The delimeter is important because the array value is stored to an element attribute as a string.
            * DEER must convert this string back and forth between an array and a string with .split()s and .join()s.
            * DEER apologizes for any inconvenience and is open to suggestions.

            * Be mindful with how you handle this.  In the example below, it is left unhandled.  
        */
        function handleTextGroup(event){
            let container = event.target.parentElement
            let texts = Array.from(container.getElementsByTagName("INPUT"))
            let delim = (container.previousElementSibling.hasAttribute("deer-array-delimeter")) ? container.previousElementSibling.getAttribute("deer-array-delimeter") : ","
            let value_arr =  Array.from(texts.filter(input => input.value)
                .map(input=>input.value)) //Note that delimeter handling would happen here.  
            let str_arr = value_arr.join(delim)
            //Your hidden input that tracks array values should always be just before the element containing the multitude of options
            container.previousElementSibling.value=str_arr
            container.previousElementSibling.setAttribute("value", str_arr)
            textChoices.innerHTML = str_arr
        }
    </script>
    <script src="https://centerfordigitalhumanities.github.io/deer/releases/alpha-0.9/deer.js" type="module"></script>
</body>
</html>